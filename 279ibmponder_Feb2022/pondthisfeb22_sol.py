'''
IBM Ponder This challenge main and bonus *, Feb 22
https://research.ibm.com/haifa/ponderthis/challenges/February2022.html
Sanandan Swaminathan, submitted Feb 1, 2022

Main puzzle answer (200-digit number consisting of only 1s and 0s, with leading 1, having 125 summands of the desired type):

10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

[(442, 0), (440, 1), (438, 4), (437, 5), (436, 6), (431, 12), (429, 14), (422, 19), (419, 22), (416, 24), (415, 25), (414, 26), (413, 27), (409, 30), (405, 36), (402, 38), (399, 40), (396, 43), (395, 46), (394, 48), (393, 53), (392, 54), (388, 57), (385, 59), (384, 61), (383, 62), (382, 65), (379, 67), (378, 70), (377, 71), (376, 72), (373, 75), (372, 76), (371, 77), (370, 78), (369, 80), (366, 82), (364, 84), (363, 86), (360, 88), (359, 89), (358, 90), (356, 93), (355, 96), (354, 99), (353, 101), (351, 103), (349, 105), (347, 107), (344, 109), (342, 113), (341, 115), (340, 116), (339, 119), (336, 121), (335, 123), (333, 124), (332, 128), (331, 131), (328, 135), (325, 137), (322, 141), (320, 142), (319, 145), (318, 146), (315, 149), (313, 153), (310, 156), (309, 158), (308, 160), (307, 161), (303, 164), (302, 165), (300, 168), (299, 169), (297, 171), (296, 172), (294, 175), (293, 177), (288, 183), (284, 185), (283, 188), (282, 189), (281, 190), (279, 192), (278, 193), (277, 195), (276, 197), (274, 199), (269, 204), (267, 205), (266, 206), (262, 212), (255, 216), (254, 217), (253, 218), (252, 222), (251, 224), (250, 225), (248, 228), (246, 230), (243, 237), (241, 241), (240, 243), (239, 246), (235, 249), (234, 250), (233, 252), (232, 253), (230, 255), (228, 258), (226, 263), (223, 265), (220, 267), (218, 269), (216, 272), (214, 274), (213, 277), (212, 278), (211, 279), (208, 281), (207, 283), (206, 284), (200, 290), (199, 291)]

Bonus "*" puzzle answer (300-digit number consisting of only 1s and 0s, with leading 1, having 200 summands of the desired type):

100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

[(682, 0), (680, 1), (677, 4), (676, 5), (673, 7), (671, 13), (669, 15), (663, 19), (662, 20), (661, 22), (657, 25), (656, 26), (655, 28), (654, 29), (653, 30), (651, 34), (650, 36), (648, 37), (647, 39), (646, 40), (644, 42), (643, 47), (641, 48), (640, 49), (639, 50), (637, 52), (636, 53), (634, 56), (633, 59), (632, 62), (629, 64), (627, 67), (626, 69), (625, 70), (624, 72), (623, 73), (622, 78), (619, 82), (616, 86), (614, 87), (612, 91), (610, 93), (609, 94), (608, 96), (607, 97), (605, 102), (603, 107), (599, 109), (593, 114), (589, 118), (587, 119), (583, 123), (582, 125), (580, 127), (574, 132), (572, 135), (570, 136), (569, 137), (568, 138), (564, 141), (560, 145), (558, 147), (555, 149), (553, 151), (550, 153), (549, 157), (548, 159), (546, 162), (544, 163), (542, 165), (538, 169), (537, 170), (533, 173), (532, 175), (529, 177), (528, 182), (526, 184), (524, 185), (523, 186), (522, 187), (521, 189), (520, 190), (516, 193), (515, 194), (514, 195), (511, 198), (509, 200), (508, 201), (505, 203), (504, 204), (503, 209), (502, 210), (500, 214), (498, 216), (497, 217), (493, 220), (492, 221), (490, 223), (487, 225), (486, 226), (484, 228), (483, 230), (480, 232), (477, 235), (473, 241), (472, 243), (471, 244), (470, 245), (469, 247), (467, 248), (465, 253), (460, 256), (459, 257), (458, 258), (457, 259), (456, 262), (455, 265), (453, 267), (448, 271), (443, 275), (442, 276), (441, 278), (438, 280), (434, 284), (432, 286), (431, 287), (430, 288), (429, 290), (428, 291), (427, 292), (426, 293), (425, 294), (421, 297), (420, 298), (417, 304), (415, 305), (414, 306), (413, 307), (409, 310), (407, 312), (406, 313), (404, 316), (403, 317), (402, 319), (400, 320), (399, 321), (397, 323), (396, 325), (390, 330), (387, 332), (386, 333), (382, 336), (381, 337), (380, 339), (379, 342), (377, 343), (376, 346), (375, 348), (374, 349), (371, 352), (368, 355), (366, 356), (365, 358), (362, 360), (361, 361), (358, 364), (355, 366), (354, 368), (353, 369), (352, 370), (351, 371), (349, 373), (347, 375), (345, 378), (344, 380), (343, 383), (342, 387), (340, 389), (338, 391), (337, 392), (334, 395), (333, 397), (331, 400), (329, 402), (324, 405), (323, 406), (322, 408), (319, 410), (314, 414), (313, 416), (312, 417), (311, 419), (308, 422), (306, 423), (305, 426), (304, 427), (303, 430), (302, 432), (301, 433), (299, 438)]

I took a recursive approach to the problem. If a number is divisible by 2, then its summands are simply 2 multiplied by the summands of 
half the number. If a number is not divisible by 2, we can consider the greatest power of 3 less than or equal to the number. This will 
be a non-conflicting summand for this number. We can reduce the number by this greatest power of 3, and get a smaller, even number. We 
can iterate through the smaller and smaller numbers using the same ideas. I wrote a Python program and it completed instantaneously for 
both the main and bonus "*" puzzles. For the mail puzzle, it produced the desired result for the very first 200-digit number of the 
desired kind (10^199), giving 125 summands. For the bonus "*" puzzle also, it gave the desired result for the very first 300-digit number 
of the desired kind (10^299), giving 200 summands. Since the summands have powers of one of the bases (2 or 3) in strictly ascending 
order, and the other one in strictly descending order, clearly no two summands can fully divide each other.

'''

import math
mylist = []
cnt=0
#x_orig=10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
x_orig=100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
x=x_orig
print(x)
while x > 1:
    if x%2 == 1:
        z=math.floor(math.log(x,3))
        x=x-(3**z)
        mylist.append(z)
        endswith=3
        cnt=cnt+1
    else:
        i=0
        while x%2 == 0:
            x=x//2
            i=i+1
        mylist.append(i)
        endswith=2
results = []
i=len(mylist)-1
if endswith == 2:
    results.append([mylist[i],0])
    endswith=3
else:
    results.append([0,mylist[i]])
    endswith=2
i=i-1
while i >= 0:
    exponent=mylist[i]
    if endswith == 2:
        j=0
        while j < len(results):
            results[j][0]=results[j][0]+exponent
            j=j+1
        endswith=3
    else:
        results.insert(0,[0,exponent])
        endswith=2
    i=i-1
r=len(results)-1
print('[', end="")
while r >= 0:
    print('('+str(results[r][0])+", "+str(results[r][1])+"), ", end="")
    r=r-1
print(']')
print("Number of summands:"+str(len(results)))
#verify solution
sum=0
r=len(results)-1
while r >= 0:
    sum = sum + ((2**(results[r][0]))*(3**(results[r][1])))
    r=r-1
print("Length of number:"+str(len(str(sum))))
if sum == x_orig:
    print("Solution verified")
else:
    printf("Failed")

